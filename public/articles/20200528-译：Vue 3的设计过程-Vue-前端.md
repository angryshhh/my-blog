原文地址：[The process: Making Vue 3](https://increment.com/frontend/making-vue-3/)

过去几年，Vue团队致力于开发Vue.js的下一个主要版本，我们希望能在2020年上半年发布它。（这项工作在写这篇文章时仍在进行。）开发Vue的新的主要版本的想法形成于2018年晚间，当时Vue 2的代码库已经有两年半之久了。对于通用软件的生命周期来说，这听起来不像一个很长的时间，但这在这期间，前端领域发生了巨大的改变。

两个关键的考虑促使我们开发Vue的新的主要版本（和重写）：第一，在主流浏览器中，JavaScript语言的新特性获得了普遍支持。第二，过去的时间里，现有的代码库暴露出来的设计和架构问题。

# 为什么重写

## 利用新语言特性

随着ES2015的标准化进程，JavaScript——正式的叫法是ECMAScript，简称ES——获得了重要提升，并且主流浏览器也终于开始为这些新特性提供合适的支持。尤其是其中某些改进，为我们极大提升Vue的能力，带来了机遇。

其中最值得注意的是[Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，它使框架可以拦截对对象的操作。Vue的一个核心特性，就是能够监听用户定义的状态的改变，并响应式地更新DOM。Vue 2通过用getters和setters来替代状态的属性，实现了这一能力。切换到Proxy，可以使我们消除Vue的已有限制，比如无法察觉状态的新增属性，并提供更好的性能。

但是，Proxy这一原生语言特性，还不能完全被polifilled，来让老浏览器兼容。为了利用它，我们知道我们必须调整框架的浏览器支持范围——这是一个只能在新的主要版本中才能获得的重大改变。

## 处理架构问题

在维护Vue 2的过程中，我们积累了不少问题，它们因为现有的架构限制，很难得到处理。比如，模板编译器的编写方式，使得构建对正确的源码映射（source-map)的支持相当困难。另外，虽然Vue 2技术上实现了构建更高级的针对无DOM平台的渲染器（building higher-level renderers that target non-DOM platforms），但为了实现它，我们不得不fork代码库，并复用了很多代码。在现有的代码库中修复这些问题，需要庞大且危险的重构工作，基本上就等同于重写了。

同时，我们积累了一些技术债，就是各种模块内部和似乎没有归属的floating code之间的隐式耦合。这使得很难单独理解代码库中的某一部分，而且，我们注意到，贡献者没那么自信对代码出非凡的改变。重写能够给我们机会，带着这些问题，重新思考代码的组织。

# 初始建模阶段

在2018年晚间，我们开始对Vue 3进行建模，初步目标是验证针对以上问题的解决方案。在这个阶段，我们主要关注于为将来的开发构建一个扎实的基础。

## 切换到TypeScript

Vue 2一开始是用纯ES写的。建模阶段开始后不久，我们认识到类型系统对一个如此巨大的项目很有帮助。类型检查极大地减少了在重构过程中引入意外bug的可能性，并让贡献者能够更自信地带来非凡改变。我们使用了Facebook的[Flow类型检查器](https://flow.org/)，因为它可以被逐渐地添加到一个已有的纯ES项目中。FLow在一定程度上给我们带来了帮助，但我们没有得到我们一开始期望的那么多的收益；尤其是，持续的重大改变让升级很痛苦。对比TypeScript 在Visual Studio Code中的深度集成，FLow的对集成开发环境的支持也不是很理想。

我们还注意到，将Vue和TypeScript一起使用的用户越来越多。为了支持他们的用例，我们必须独立于源码来编写并维护TypeScript声明，因为源码使用不同的类型系统。切换到TypeScript能让我们自动生成声明文件，减少维护负担。

## 解耦内部包

我们还使用了monorepo配置，在这个配置下，框架是由内部包组成，每个包有它们自己单独的API、类型定义和测试。我们希望让这些模块捡的相互依赖更明确，这样开发者更易读、易懂，并对整体进行改变。这对我们努力降低项目贡献门槛，以及提升长期可维持性来说，都很关键。

## 设置RFC流程

到2018年结束前，我们有了一个能用的原型，它有新的响应式系统和虚拟DOM渲染器。我们验证了我们想实现的内部架构提升，但只有很粗糙的面向公众的API改变的草案。是时候具体实现它们了。

我们知道我们必须尽早并且很谨慎地做这件事。Vue广泛的使用，意味着重大改变会给用户带来巨大的迁移代价，以及潜在的生态崩溃。为保证用户能对重大改变作出反馈，我们在2019年一开始，引入了[RFC（Request for Comments）流程](https://github.com/vuejs/rfcs)。每个RFC都使用一个模板，模板的每部分分别关注于动机、设计细节、权衡以及引入策略。因为该过程在一个GitHub库中进行，提议以pull request的形式提交，所以相关讨论在comments中有机展开。

RFC流程已经被证实很有帮助，它以思维框架的形式，迫使我们充分思考一个潜在改变的方方面面，并使我们的社区参与到设计流程中，并提交经过深思熟虑的功能需求。

# 更快更小

性能对前端框架来说是很重要的。尽管Vue 2在性能上已经很有竞争力了，但是通过尝试新的渲染策略，重写为进一步提升性能带来了机会。

## 克服虚拟DOM的瓶颈

Vue的渲染策略相当独特：它提供一个类似HTML的模板语法，但将模板编译成渲染函数，渲染函数返回虚拟DOM树。框架通过递归式地遍历两个虚拟DOM树并比较每个节点的属性，来搞清楚哪部分真实DOM需要更新。这一有点蛮力的算法，归功于现代JavaScript引擎的高级优化，通常来说都很快，但更新仍然带来了许多不必要的CPU工作。当面对一个主要是静态内容而只有一丢丢动态绑定的模板时，低效就变得很明显——因为仍要递归遍历整个虚拟DOM树来搞清楚哪里发生了变化。

幸运的是，模板分析步骤让我们有可能对模板进行静态分析，并提取出动态部分的信息。Vue 2通过跳过静态子树，在一定程度上实现了这一功能，但因为过于简化的编译器架构，很难实现更高级的优化。在Vue 3中，我们用一个合适的AST转换管道（AST transform pipeline）重写了编译器，使我们可以以转换插件的形式构成编译时优化。

随着新的架构就位，我们希望找到一个渲染策略，能够尽可能的减小开支。一个选项是，抛弃虚拟DOM，直接生成命令式的DOM操作，但那会降低直接编写虚拟DOM渲染函数的能力，我们发现这一能力对高级用户和库作者们来说有很大价值。另外，这会是一个重大改变。

次之，另一个不错的选项是，剔除不必要的虚拟DOM遍历和属性对比，因为在更新期间，它们倾向于带来最多的性能开支。为了实现它，编译器和运行时需要一起工作：编译器分析模板并产生有优化线索的代码，而运行时只要有可能，就会根据线索选择较快路径。这里的工作有三个主要优化：

第一，在树的层面，我们发现，没有动态改变节点结构的模板命令（比如v-if和v-for），节点结构会保持完全静态。如果我们根据这些结构命令，将一个模板分成嵌套的“块（block）”，每个块中的节点结构又变成完全静态的了。当我们在一个块中更新节点时，我们不再需要递归地访问树——块内的动态绑定可以在一个一位数组中被跟踪。这一优化通过减少一个数量级的树的访问，规避了大量虚拟DOM的开支。

第二，编译器尽可能地检测模板中的静态的节点、子树、甚至是数据对象（data objects），并在生成的代码中将它们提升到渲染函数外。这避免了在每次渲染时重新创建这些对象，极大地提升了内存利用，并减少了垃圾收集的频率。

第三，元素（element）层面，每个有动态绑定的元素，编译器会根据它要进行的更新类型，给它一个优化标识。比如，一个有动态类型绑定（dynamic class binding）和许多静态属性（attribute）的元素，会得到一个标识，表明只需要一个类型检查。运行时会根据这些线索，走专门的快速路径。

结合起来，这些技术显著地提高了我们的渲染更新基准，使得Vue 3有时花费的CPU时间，比Vue 2的十分之一还少。

## 减小打包（bundle）大小

框架的大小也会影响性能。这是web应用独有的关心点，因为资源需要赶紧下载，并且直到浏览器解析完JavaScript才能和应用交互。对单页面应用来说尤其如此。虽然Vue一直以来都是相对轻量级的——Vue 2的运行时压缩后大小大约有23KB——我们仍注意到两个问题：

第一，不是每个人都会使用到框架的所有特性。比如，一个永不使用过渡功能的应用，仍得负担下载和解析过渡相关代码的代价。

第二，只要我们加入新特性，框架就会无限期变大。所以当我们考虑到新特性的收益与开支时，打包的大小会获得不成比例的权重。因此，我们倾向只纳入大部分用户会使用的特性。

理想情况下，用户在build时应该可以抛弃框架中没有用到的特性的代码——AKA“tree shaking”——只负担他们用到的代码。这也会使我们能够加入我们部分用户觉得有用的特性，而不给其他用户带来加载开支。

在Vue 3中，我们通过将大部分全局API和内部助手（internal helper）移到ES模块导出（export）中，来实现以上特性。这使得现代打包器（bundler）能静态地分析模块依赖，并丢弃未使用的导出的相关代码。模板编译器也会生成tree-shaking友好型的代码，代码只引入（import）模板中确实用到的功能的助手（helper）。

框架的某些部分永远不会被tree-shaken，因为它们对任意类型的应用来说都是必要的。我们称这些不可或缺部分的度量为基础大小（baseline size）。不算许多新增特性，Vue 3的基础大小压缩后大概是10KB——比Vue 2的一半还小。

# 处理对规模的需求

我们还希望提升Vue处理大规模应用的能力。我们最初的Vue设计关注于低入门门槛，和一个温和的学习曲线。但随着Vue被广泛使用，我们了解到了来自包含上百个模块，由许多开发人员维护的项目的需求。对于这类项目，像TypeScript一样的类型系统和能被干净地组织和可复用的代码是很重要的，但Vue 2对于这些领域的支持并不理想。

在Vue 3的早期设计中，我们企图对使用类（class）编写组件提供内建的支持，来提高TypeScript的集成。这里的挑战是，要让类可用，我们需要用的很多语言特性，比如类字段（class field）和装饰（decorator），仍处于提议阶段，而且它们在正式变成JavaScript的一部分之前还会改变。Class API带来的复杂度和不确定性，让我们自问加入它的理由是否充分，毕竟除了提供更好那么一点点的TypeScript集成，它不带来任何好处。

我们觉定调查其他方法来解决规模问题。受React Hooks的启发，我们考虑将更底层的响应和组件生命周期API暴露出来，来实现一个更独创（free-form）的编写组件逻辑的方式，称之为[Composition API](https://vue-composition-api-rfc.netlify.app/)。不再是通过具体说明一长列选项来定义一个组件，Composition API使用户可以像写一个函数一样，自由地表示、组成和复用有状态的组件逻辑，同时全都提供极好的TypeScript支持。

我们对这个点子感到很兴奋。虽然设计Composition API是来处理某一具体种类的问题，但技术上来说，仅当编写组件时，使用它是可以的（译者：这没看懂）。在该提议的第一个草案，我们有一点超越自我（get a bit ahead of ourselves），暗示我们可能会在将来的发行中，用Composition API来替代现有的Options API。这导致了社区成员的强烈抵制，从中我们上了有价值的一课 ，关于沟通长期计划和意图，还有理解用户需求。在听了我们社区的反馈后，我们完全修改了提议，明确Composition API会是添加性的，和Options API形成互补。修改后的提议得到了更积极的接纳，并受到了很多建设性的建议。

# 寻求平衡

Vue的用户基础中有超过一百万的开发者，其中有仅有基础HTML/CSS知识的初学者，从jQuery进化来的专业人员，从其他框架转来的老手，还有处理规模化软件的软件设计师。开发者测写的多样性，和用例多样性相对应：一些开发者可能想在老旧应用上添加一些交互性，还有些可能在开发需要快速交付不需要考虑维护的一次性项目；设计师可能要在项目生命周期中处理大规模、多层的项目，和变化的开发团队。

因为我们在多个权衡中寻求平衡，Vue的设计一直以来都受以上需求的塑造和启发。Vue 的口号“一个渐进式框架”，概括了这一过程中诞生的分层API设计。初学者使用CDN脚本、基于HTML的模板和直觉式的Options API，可以体验到顺滑的学习曲线，而专业人员可以使用功能完善的CLI、渲染函数和Composition API来处理更有野心的用例。

要实现我们的愿景，还有很多工作要做——最重要的是，更新支持库、文档和工具，来保证顺滑的迁移。接下来的几个月，我们会努力工作，我们已经等不及想见到社区会用Vue 3开发出什么。
